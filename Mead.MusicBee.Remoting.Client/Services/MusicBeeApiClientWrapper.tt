<#@ template language="C#" #>
<#@ assembly name="$(SolutionDir)\Mead.MusicBee.MetaInfo\bin\Debug\net472\Mead.MusicBee.MetaInfo.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Entities" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Extensions" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Helpers" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Services" #>
//-------------------------
// Autogenerated using t4 |
//-------------------------

using System.Drawing;
using System.Windows.Forms;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Mead.MusicBee.Api.Services.Abstract;
using Mead.MusicBee.Enums;

namespace Mead.MusicBee.Remoting.Client.Services;

public sealed class MusicBeeApiClientWrapper : IMusicBeeApi
{
    private readonly MusicBeeApiService.MusicBeeApiServiceClient _client;

    public MusicBeeApiClientWrapper(MusicBeeApiService.MusicBeeApiServiceClient client)
    {
        _client = client;
    }
<#
    foreach (var method in _methods)
    {
        var returnType = method.ReturnParameter.Type.GetCSharpAlias();
        var arguments = method.GetClassMethodArguments();
        var responseAssignment = method.HasAnyOutputParameters()
            ? "var response = "
            : string.Empty;
        var requestType = _namingService.GetRequestMessageType(method);
        var closing = method.HasInputParameters()
            ? string.Empty
            : "());";
#>

    public <#= returnType #> <#= method.Name #>(<#= arguments #>)
    {
        <#= responseAssignment #>_client.<#= method.Name #>(new <#= requestType #><#= closing #>
<#
        if (method.HasInputParameters())
        {
#>
        {
<#
            foreach (var inputParameter in method.InputParameters)
            {
                var property = inputParameter.Name.Capitalize();
                var value = GetRequestPropertyValue(inputParameter);
#>
            <#= property #> = <#= value #>,
<#
            }
#>
        });
<#
        }

        foreach (var outputParameter in method.OutputParameters)
        {
            var enumCast = outputParameter.Type.IsEnum
                ? $"({outputParameter.Type.Name})"
                : string.Empty;
            var propertyName = outputParameter.Name.Capitalize();
            var arrayCast = GetOutputParameterArrayCast(outputParameter);
#>
        <#= outputParameter.Name #> = <#= enumCast #>response.<#= propertyName #><#= arrayCast #>;
<#
        }

        if (method.HasReturnType())
        {
            var enumCast = method.ReturnParameter.Type.IsEnum
                ? $"({method.ReturnParameter.Type.Name})"
                : string.Empty;
#>
        return <#= enumCast #>response.Result;
<#
        }
#>
    }
<#
    }

    foreach (var method in _unsupportedMethods)
    {
        var returnType = method.ReturnParameter.Type.GetCSharpAlias();
        var arguments = method.GetClassMethodArguments();
#>

    public <#= returnType #> <#= method.Name #>(<#= arguments #>)
    {
        throw new NotSupportedException("Method could not be called remotely.");
    }
<#
    }
#>
}
<#+
    private readonly IReadOnlyCollection<MethodDefinition> _methods =
        MetaInfoProvider.GetMethodsWithoutRestrictions();

    private readonly IReadOnlyCollection<MethodDefinition> _unsupportedMethods =
        MetaInfoProvider.GetOSSpecificMethods();

    private readonly ProtobufNamingService _namingService = new(
        "Empty",
        "_Request",
        "_Response");

    private static string GetRequestPropertyValue(ParameterDefinition parameter)
    {
        return GetRequestPropertyValue(parameter.Type, parameter.Name);
    }

    private static string GetRequestPropertyValue(Type parameterType, string parameterName)
    {
        if (parameterType.IsEnumerable() && parameterType.HasElementType)
        {
            var elementType = parameterType.GetElementType()!;
            if (elementType == typeof(byte))
            {
                return $"ByteString.CopyFrom({parameterName})";
            }

            return elementType.IsEnum
                ? $"{{ {parameterName}.Cast<int>() }}"
                : $"{{ {parameterName} }}";
        }

        return parameterType.IsEnum
            ? $"(int){parameterName}"
            : parameterName;
    }

    private static string GetOutputParameterArrayCast(ParameterDefinition parameter)
    {
        if (!parameter.Type.IsArray)
        {
            return string.Empty;
        }

        if (parameter.Type.HasElementType
            && parameter.Type.GetElementType()! == typeof(byte))
        {
            return ".ToByteArray()";
        }

        return ".ToArray()";
    }
#>
<#@ template language="C#" #>
<#@ assembly name="$(SolutionDir)\Mead.MusicBee.MetaInfo\bin\Debug\net472\Mead.MusicBee.MetaInfo.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Entities" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Extensions" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Helpers" #>
<#@ import namespace="Mead.MusicBee.MetaInfo.Services" #>
//-------------------------
// Autogenerated using t4 |
//-------------------------

using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
using Mead.MusicBee.Api.Services.Abstract;
using Mead.MusicBee.Enums;

// ReSharper disable ConstantNullCoalescingCondition

namespace Mead.MusicBee.Remoting.Plugin;

public sealed class MusicBeeApiServiceImpl : MusicBeeApiService.MusicBeeApiServiceBase
{
    private readonly IMusicBeeApi _musicBeeApi;

    public MusicBeeApiServiceImpl(IMusicBeeApi musicBeeApi)
    {
        _musicBeeApi = musicBeeApi;
    }
<#
    foreach (var method in _methods)
    {
        var responseMessageType = _namingService.GetResponseMessageType(method);
        var requestMessageType = _namingService.GetRequestMessageType(method);
        var arguments = GetMethodCallingArguments(method);
#>

    public override Task<<#= responseMessageType #>> <#= method.Name #>(<#= requestMessageType #> request, ServerCallContext context)
    {
        return Task.Run(() =>
        {
<#
        if (method.HasReturnType())
        {
#>
            var result = _musicBeeApi.<#= method.Name #>(<#= arguments #>);
<#
        }
        else
        {
#>
            _musicBeeApi.<#= method.Name #>(<#= arguments #>);
<#
        }

        if (!method.HasAnyOutputParameters())
        {
#>
            return new <#= responseMessageType #>();
<#
        }
        else
        {
#>
            return new <#= responseMessageType #>
            {
<#
            if (method.HasReturnType())
            {
                var value = GetResponseValue(method.ReturnParameter, "result");
#>
                Result = <#= value #>,
<#
            }

            foreach (var outputParameter in method.OutputParameters)
            {
                var property = outputParameter.Name.Capitalize();
                var value = GetResponseValue(outputParameter);
#>
                <#= property #> = <#= value #>,
<#
            }
#>
            };
<#
        }
#>
        });
    }
<#
    }
#>
}
<#+
    private readonly IReadOnlyCollection<MethodDefinition> _methods =
        MetaInfoProvider.GetMethodsWithoutRestrictions();

    private readonly ProtobufNamingService _namingService = new(
        "Empty",
        "_Request",
        "_Response");

    private static string GetMethodCallingArguments(MethodDefinition method)
    {
        var inputArguments = method.InputParameters
            .Select(GetCallingInputArgument);
        var outputArguments = method.OutputParameters
            .Select(x => $"out var {x.Name}");
        return string.Join(", ", inputArguments.Concat(outputArguments));
    }

    private static string GetCallingInputArgument(ParameterDefinition parameter)
    {
        var enumCast = parameter.Type.IsEnum
            ? $"({parameter.Type.Name})"
            : string.Empty;
        var propertyName = parameter.Name.Capitalize();
        var enumCastPostfix = GetEnumCastInCollection(parameter);
        var arrayCast = GetArrayCast(parameter);

        return $"{enumCast}request.{propertyName}{enumCastPostfix}{arrayCast}";
    }

    private static string GetEnumCastInCollection(ParameterDefinition parameter)
    {
        if (!parameter.Type.IsArray || !parameter.Type.HasElementType)
        {
            return string.Empty;
        }

        var elementType = parameter.Type.GetElementType()!;
        return elementType.IsEnum
            ? $".Cast<{elementType.Name}>()"
            : string.Empty;
    }

    private static string GetArrayCast(ParameterDefinition parameter)
    {
        if (!parameter.Type.IsEnumerable(out var elementType))
        {
            return string.Empty;
        }

        return elementType == typeof(byte)
            ? ".ToByteArray()"
            : ".ToArray()";
    }

    private static string GetResponseValue(ParameterDefinition parameter)
    {
        return GetResponseValue(parameter, parameter.Name);
    }

    private static string GetResponseValue(ParameterDefinition parameter, string parameterName)
    {
        if (parameter.Type.IsEnumerable() && parameter.Type.HasElementType)
        {
            var elementType = parameter.Type.GetElementType();
            if (elementType is null)
            {
                throw new NotSupportedException("Could not generate code for enumerable without element type.");
            }

            var nullablePart = parameter.IsNullable
                ? $" ?? Array.Empty<{elementType.GetCSharpAlias()}>()"
                : string.Empty;

            return elementType == typeof(byte)
                ? $"ByteString.CopyFrom({parameterName}{nullablePart})"
                : $"{{ {parameterName}{nullablePart} }}";
        }

        return parameter.Type.IsEnum
            ? $"(int){parameterName}"
            : parameterName;
    }
#>